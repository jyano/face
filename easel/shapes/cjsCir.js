h.dc = function () {
	var h = this, gx = h.graphics, g = G(arguments)
	h.cp() // ?
	if (g.A) {
		return $a(h, 'dc', g.f)
	}
	if (g.OO_) {
		return h.cirs(g)
	}
	gx._dc.apply(gx, g)
	return h
}
h.cir = function () {
	var h = this, gx = h.graphics, g = G(arguments), o
	if (g.A) {
		return $a(h, 'cir', g.f)
	}
	if (g.OO_) {
		return h.cirs(g)
	}
	o = g.O ? g.f :
			N(g.t) ? {x: g.f, y: g.s, r: g.t, c: g.fo, C: g.fi, l: g.si} :
					N(g.s) ? {x: g.f, y: g.s, c: g.t, C: g.fo, l: g.fi} : g.N_ ? {
						r: g.f,
						c: g.s,
						C: g.t,
						l: g.fo
					} : {c: g.f, C: g.s, l: g.t}
	//o.c = o.c || 'w'; o.C = o.C || 'z'; o.l = N(o.l, 4)
	h.c(o)
	function replaced() {
		if (o.c) {
			h.c(o.c)
		}
		if (o.C) {
			h.C(o.C)
		}
		if (N(o.l)) {
			h.l(o.l)
		}
		h.cp()
		h._dc(o)
	}
	
	if (o.bf) {
		if (N(o.bf)) {
			o.bm = 'me'
		}
		if (F(Q)) { //async
			h.bf(o.bf, function () {
				h.dc(o)
			})
		}
		else { //sync
			o.tf = o.tf || null;
			h.bf(o.bf, o.tf).dc(o)
		}
	}
	else {
		h.dc(o)
	}
	h.alpha = N(o.al, 1)
	return h
}
cj.cir = function () {
	var g = G(arguments), o
	var h = $Sh()
	if (g.p) {
		h.drag()
	}
	o = g.O ? g.f :
			N(g.f) && N(g.s) && N(g.t) ?
			{r: g.f, x: g.s, y: g.t, c: g.fo, C: g.fi, l: g.si} :
					N(g.f) && N(g.s) ? {x: g.f, y: g.s, c: g.t, C: g.fo, l: g.fi} :
							g.N_ ? {r: g.f, c: g.s, C: g.t, l: g.fo} :
							{c: g.f, C: g.s, l: g.t}
	h.cir(o.r, o.c, o.C, o.l)
	h.regX = -N(o.x, 0)
	h.regY = -N(o.y, 0)
	h.alpha = N(o.al, 1)
	return h
	// old: cir0: x, y, rad, fCol, sCol ( h = $Sh().XY(N(g.f, 0), N(g.s, 0)) )
	//h.f(fCol || 'z')
	//var fCol = g.fo || 'w'
	//var sCol = g.fi || 'z'
	//if (sCol) {	 h.s(sCol) }
	//h.cir(0, 0, rad)
	//if (g.O) {	 var cir = g.f
	//return cjs.cir0(cir.x, cir.y, cir.r, cir.fC, cir.sC)	 }
	//h.cir(x, y, r, fCol, sCol)
}
$Cir = function () {
	var g = G(arguments), o
	o = S(g.f) ?
	{c: g.f, x: g.s, y: g.t, r: g.fo} :
	{x: g.f, y: g.s, r: g.t}
	return $H(o.c, o.x, o.y).dc(o.r)
}
$Sh = $H = $h = function (x) {
	var g = G(arguments), o
	var h = new cjs.Shape(cjs.iH(x) ? x.graphics : x)
	//pass in your own obj to use 'o.i/o.bf'
	o = g.O ? g.f : // or 'o.lf' or 'o.rf'
			N(g.fo) ? {x: g.f, y: g.s, C: g.t, lW: g.fo} : //x,y C-l
					N(g.f) ? {x: g.f, y: g.s, c: g.t, C: g.fo, lW: g.fi} : //x,y c-C-l
							N(g.s) ? {C: g.f, lW: g.s} : // C-l
							{c: g.f, C: g.s, lW: g.t} // c-C-l
	h.XY(N(o.x, 0), N(o.y, 0))
	//h.c(o.c || 'z', o.C || 'w', o.lW || 8)
	if (o.c) {
		h.c(o.c)
	}
	if (o.C) {
		h.C(o.C)
	}
	if (N(o.lW)) {
		h.l(o.lW)
	}
	if (g.p) {
		h.dg()
	}
	return h
}
h.cirs = function () {
	var h = this, g = G(arguments)
	_.e(g.A ? g.f : g, function (c) {
		
		//h.es()
		h.s()
		h.dc(c)
	})
	return this
}
ct.dc = function (x, y, r, f, s, width, opt) {
	return this.shape(x, y, f, s, width, opt).dc(0, 0, r)
}
ct.cir = function () {
	var h = this.h()
	return h.cir.apply(h, arguments)
}
ct.circle = function (x, y, rad, color) {
	this.A(cjs.cir(x, y, rad, color))
	return this
}
ct.cir = function () {
	var ct = this, g = G(arguments), h = this.h(), o
	o = g.O ? g.f :
			N(g.s) ? {x: g.f, y: g.s, r: g.t, c: g[3]} :
			{r: g.f, c: g.s}
	h.c(o.c)
	h._dc(o.x, o.y, o.r)
	return h
}
 